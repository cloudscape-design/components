{"version":3,"file":"get-methods-doc.js","sourceRoot":"","sources":["../../../src/test-utils/extractor/get-methods-doc.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ReflectionKind, ParameterReflection } from 'typedoc';\nimport { ReferenceType, DeclarationReflection } from 'typedoc/dist/lib/models';\n\nimport { TestUtilMethod, Parameter } from '../interfaces';\nimport schema from '../../schema';\n\nfunction getName(methodSignature: DeclarationReflection) {\n  return methodSignature.name;\n}\n\n// TODO: Extend and reuse existing utils\nfunction getReturnType(methodSignature: DeclarationReflection) {\n  // Error is check in calling function\n  // TODO: Get right type. \"Type\" does e.g. not have .name\n  const signatureReturnType = (methodSignature.signatures![0] as any).type;\n  if (signatureReturnType === undefined) {\n    throw Error('expected return type to be defined');\n  }\n\n  const returnType = {\n    name: signatureReturnType.name,\n    type: signatureReturnType.type,\n    typeArguments: getTypeArguments(signatureReturnType.typeArguments),\n  };\n\n  // TODO: Reuse schema.code.buildType\n  if (schema.types.isArrayType(signatureReturnType)) {\n    returnType.name = signatureReturnType.type;\n    returnType.type = signatureReturnType.elementType.type;\n    returnType.typeArguments = getTypeArguments((signatureReturnType.elementType as any).typeArguments.constraint);\n  }\n\n  // TODO: Try to reuse buildUnionTypeDefinition\n  if (schema.types.isUnionType(signatureReturnType)) {\n    // TODO: This doesn't work well with the website currently\n    const returnTypeNames = signatureReturnType.types.map(t => (t as any).name).join(' | ');\n    returnType.name = returnTypeNames;\n  }\n\n  return returnType;\n}\n\nfunction getTypeArguments(typeArguments: any) {\n  if (typeArguments && typeArguments.map) {\n    return typeArguments.map((arg: any) => ({ name: arg.name, type: arg.type }));\n  }\n}\n\n// TODO: Reuse existing functionality in components\nfunction getParameters(methodSignature: DeclarationReflection): Array<Parameter> {\n  const parameters = methodSignature.signatures![0].parameters as Array<ParameterReflection> | undefined;\n  if (!parameters) {\n    return [];\n  }\n\n  const parametersDoc = parameters.map(param => ({\n    name: param.name,\n    typeName: (param.type as any)?.name,\n    description: schema.code.buildNodeDescription(param),\n    flags: { isOptional: param.flags.isOptional },\n    defaultValue: param.defaultValue ? param.defaultValue.trim() : undefined,\n  }));\n\n  return parametersDoc;\n}\n\nfunction getInheritedFrom(methodSignature: DeclarationReflection) {\n  let inheritedFrom = undefined;\n  if (methodSignature.inheritedFrom) {\n    inheritedFrom = {\n      name: (methodSignature.inheritedFrom as ReferenceType).name,\n    };\n  }\n\n  return inheritedFrom;\n}\n\nexport function getMethodsDoc(childReflections: Array<DeclarationReflection> = []): Array<TestUtilMethod> {\n  const methodReflections = childReflections.filter(child => {\n    const isPublic = !child.flags.isPrivate && !child.flags.isProtected;\n    const isMethod = child.kind === ReflectionKind.Method;\n    return isPublic && isMethod;\n  });\n\n  // TODO: Try to reuse existing functionality from components\n  const testUtilMethodsDocs = methodReflections.map(methodSignature => {\n    if (!methodSignature.signatures) {\n      throw new Error('Expected method to have signatures');\n    }\n\n    const outMethod: Partial<TestUtilMethod> = {};\n    outMethod.name = getName(methodSignature);\n    outMethod.description = schema.code.buildDeclarationDescription(methodSignature);\n    outMethod.returnType = getReturnType(methodSignature);\n    outMethod.parameters = getParameters(methodSignature);\n    outMethod.inheritedFrom = getInheritedFrom(methodSignature);\n    return outMethod as TestUtilMethod;\n  });\n\n  return testUtilMethodsDocs;\n}\n"]}