{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/schema/utils.ts"],"names":[],"mappings":";;;AAGA,mCAAyF;AAEzF,SAAgB,qBAAqB,CAAC,IAA2B;IAC/D,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;QACzB,OAAO,IAAI,CAAC;KACb;IACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACvB,OAAO,IAAI,KAAK,SAAS,IAAI,IAAA,mBAAW,EAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,SAAS,CAAC;AACnG,CAAC;AAND,sDAMC;AAED,SAAgB,uBAAuB,CAAC,EAAE,IAAI,EAAE,IAAI,EAAyB;;IAC3E,MAAM,YAAY,GAChB,IAAA,uBAAe,EAAC,IAAI,CAAC,IAAI,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,iCAAiC,CAAC,CAAC;IACrG,MAAM,wBAAwB,GAAG,OAAO,CACtC,IAAA,uBAAe,EAAC,IAAI,CAAC;QACnB,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,gBAAgB;SACrC,MAAA,MAAC,IAAI,CAAC,UAAgD,0CAAE,UAAU,0CAAE,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE;YAC1F,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAA,uBAAe,EAAC,IAAI,CAAC,IAAI,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;QAC7G,CAAC,CAAC,CAAA,CACL,CAAC;IACF,OAAO,YAAY,IAAI,wBAAwB,CAAC;AAClD,CAAC;AAXD,0DAWC;AAED,SAAgB,4BAA4B,CAAC,WAAkC;;IAC7E,OAAO,MAAA,MAAA,MAAA,WAAW,CAAC,OAAO,0CAAG,CAAC,EAAE,IAAI,0CAAE,YAAY,mCAAI,kBAAkB,CAAC;AAC3E,CAAC;AAFD,oEAEC;AAED,SAAgB,6BAA6B,CAAC,IAAe;IAC3D,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;AAC1C,CAAC;AAFD,sEAEC;AAED,SAAgB,aAAa,CAAC,IAAW;IACvC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;QACrC,OAAO,KAAK,CAAC;KACd;IACD,IAAI,IAAA,uBAAe,EAAC,IAAI,CAAC,IAAI,IAAA,uBAAe,EAAC,IAAI,CAAC,EAAE;QAClD,OAAO,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC;KAClC;IACD,IAAI,IAAA,mBAAW,EAAC,IAAI,CAAC,EAAE;QACrB,OAAO,6BAA6B,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;KACvD;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAXD,sCAWC;AAED,SAAgB,eAAe,CAAC,IAAW;IACzC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;AAC9B,CAAC;AAFD,0CAEC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { DeclarationReflection, Type, UnionType } from 'typedoc/dist/lib/models';\nimport { isIntrinsicType, isReferenceType, isTypeParameter, isUnionType } from './types';\n\nexport function isOptionalDeclaration(prop: DeclarationReflection): boolean {\n  if (prop.flags.isOptional) {\n    return true;\n  }\n  const type = prop.type;\n  return type !== undefined && isUnionType(type) && type.types.find(isTypeUndefined) !== undefined;\n}\n\nexport function isForwardRefDeclaration({ type, name }: DeclarationReflection): boolean {\n  const isForwardRef =\n    isReferenceType(type) && type.symbolFullyQualifiedName.endsWith('React.ForwardRefExoticComponent');\n  const isParametrizedForwardRef = Boolean(\n    isReferenceType(type) &&\n      type.name === `${name}ForwardRefType` &&\n      (type.reflection as DeclarationReflection | undefined)?.signatures?.some(({ name, type }) => {\n        return name === '__call' && isReferenceType(type) && type.symbolFullyQualifiedName.endsWith('JSX.Element');\n      })\n  );\n  return isForwardRef || isParametrizedForwardRef;\n}\n\nexport function getDeclarationSourceFilename(declaration: DeclarationReflection): string {\n  return declaration.sources?.[0].file?.fullFileName ?? 'unknown location';\n}\n\nexport function excludeUndefinedTypeFromUnion(type: UnionType): Type[] {\n  return type.types.filter(isTypeDefined);\n}\n\nexport function isTypeDefined(type?: Type): boolean {\n  if (type && type.type === 'undefined') {\n    return false;\n  }\n  if (isIntrinsicType(type) || isTypeParameter(type)) {\n    return type.name !== 'undefined';\n  }\n  if (isUnionType(type)) {\n    return excludeUndefinedTypeFromUnion(type).length > 0;\n  }\n  return true;\n}\n\nexport function isTypeUndefined(type?: Type): boolean {\n  return !isTypeDefined(type);\n}\n"]}