{"version":3,"file":"object-definition.js","sourceRoot":"","sources":["../../src/components/object-definition.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport ts from 'typescript';\nimport type { TypeDefinition, UnionTypeDefinition, ValueDescription } from './interfaces';\nimport { extractDeclaration, extractValueDescriptions, isOptional, stringifyType } from './type-utils';\n\nfunction isArrayType(type: ts.Type) {\n  const symbol = type.getSymbol();\n  if (!symbol) {\n    return false;\n  }\n  return symbol.getName() === 'Array' || symbol.getName() === 'ReadonlyArray';\n}\n\nexport function getObjectDefinition(\n  type: string,\n  rawType: ts.Type,\n  rawTypeNode: ts.TypeNode | undefined,\n  checker: ts.TypeChecker\n): { type: string; inlineType?: TypeDefinition } {\n  const realType = rawType.getNonNullableType();\n  const realTypeName = stringifyType(realType, checker);\n  if (\n    realType.flags & ts.TypeFlags.String ||\n    realType.flags & ts.TypeFlags.StringLiteral ||\n    realType.flags & ts.TypeFlags.Boolean ||\n    realType.flags & ts.TypeFlags.Number ||\n    isArrayType(realType) ||\n    realTypeName === 'HTMLElement'\n  ) {\n    // do not expand built-in Javascript methods or primitive values\n    return { type };\n  }\n  if (realType.isUnionOrIntersection()) {\n    return getUnionTypeDefinition(realTypeName, realType, rawTypeNode, checker);\n  }\n  if (realType.getProperties().length > 0) {\n    return {\n      type: type,\n      inlineType: {\n        name: realTypeName,\n        type: 'object',\n        properties: realType\n          .getProperties()\n          .map(prop => {\n            const propType = checker.getTypeAtLocation(extractDeclaration(prop));\n            return {\n              name: prop.getName(),\n              type: stringifyType(propType, checker),\n              optional: isOptional(propType),\n            };\n          })\n          .sort((a, b) => a.name.localeCompare(b.name)),\n      },\n    };\n  }\n  if (realType.getCallSignatures().length > 0) {\n    if (realType.getCallSignatures().length > 1) {\n      throw new Error('Multiple call signatures are not supported');\n    }\n    const signature = realType.getCallSignatures()[0];\n\n    return {\n      type,\n      inlineType: {\n        name: realTypeName,\n        type: 'function',\n        returnType: stringifyType(signature.getReturnType(), checker),\n        parameters: signature.getParameters().map(param => {\n          const paramType = checker.getTypeAtLocation(extractDeclaration(param));\n          return {\n            name: param.getName(),\n            type: stringifyType(paramType, checker),\n          };\n        }),\n      },\n    };\n  }\n  return { type };\n}\n\nfunction getPrimitiveType(type: ts.UnionOrIntersectionType) {\n  if (type.types.every(subtype => subtype.isStringLiteral())) {\n    return 'string';\n  }\n  if (type.types.every(subtype => subtype.isNumberLiteral())) {\n    return 'number';\n  }\n  return undefined;\n}\n\nfunction getUnionTypeDefinition(\n  realTypeName: string,\n  realType: ts.UnionOrIntersectionType,\n  typeNode: ts.TypeNode | undefined,\n  checker: ts.TypeChecker\n): { type: string; inlineType: UnionTypeDefinition } {\n  const valueDescriptions = extractValueDescriptions(realType, typeNode);\n  const primitiveType = getPrimitiveType(realType);\n  const values = realType.types.map(subtype =>\n    primitiveType ? (subtype as ts.LiteralType).value.toString() : stringifyType(subtype, checker)\n  );\n\n  return {\n    type: primitiveType ?? realTypeName,\n    inlineType: {\n      name: realTypeName,\n      type: 'union',\n      valueDescriptions: valueDescriptions.length > 0 ? zipValueDescriptions(values, valueDescriptions) : undefined,\n      values: values,\n    },\n  };\n}\n\nfunction zipValueDescriptions(values: Array<string>, descriptions: Array<ValueDescription | undefined>) {\n  const descriptionsMap: Record<string, ValueDescription> = {};\n  values.forEach((value, index) => {\n    const description = descriptions[index];\n    if (description) {\n      descriptionsMap[value] = description;\n    }\n  });\n  return descriptionsMap;\n}\n"]}