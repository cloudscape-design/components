{"version":3,"file":"extractor.js","sourceRoot":"","sources":["../../src/components/extractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport ts from 'typescript';\n\nimport {\n  extractDeclaration,\n  getDescription,\n  isOptional,\n  stringifyType,\n  unwrapNamespaceDeclaration,\n} from './type-utils';\n\nexport interface ExtractedDescription {\n  text: string | undefined;\n  tags: Array<{ name: string; text: string | undefined }>;\n}\n\nexport interface ExpandedProp {\n  name: string;\n  type: string;\n  isOptional: boolean;\n  rawType: ts.Type;\n  rawTypeNode: ts.TypeNode | undefined;\n  description: ExtractedDescription;\n}\n\nexport function extractDefaultValues(exportSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  let declaration: ts.Node = extractDeclaration(exportSymbol);\n  if (ts.isExportAssignment(declaration)) {\n    // Traverse from \"export default Something;\" to the actual \"Something\"\n    const symbol = checker.getSymbolAtLocation(declaration.expression);\n    if (!symbol) {\n      throw new Error('Cannot resolve symbol');\n    }\n    declaration = extractDeclaration(symbol);\n  }\n  // Extract \"Something\" from \"const Component = Something\"\n  if (ts.isVariableDeclaration(declaration) && declaration.initializer) {\n    declaration = declaration.initializer;\n  }\n  // Extract \"Something\" from \"Something as MyComponentType\"\n  if (ts.isAsExpression(declaration)) {\n    declaration = declaration.expression;\n  }\n  // Extract \"Something from React.forwardRef(Something)\"\n  if (\n    ts.isCallExpression(declaration) &&\n    (declaration.expression.getText() === 'React.forwardRef' || declaration.expression.getText() === 'forwardRef')\n  ) {\n    declaration = declaration.arguments[0];\n  }\n\n  // In the component function, find arguments destructuring\n  let argument: ts.Node | undefined;\n  if (\n    ts.isFunctionDeclaration(declaration) ||\n    ts.isFunctionExpression(declaration) ||\n    ts.isArrowFunction(declaration)\n  ) {\n    if (declaration.parameters.length === 0) {\n      return {};\n    }\n    argument = declaration.parameters[0].name;\n  }\n  if (!argument) {\n    throw new Error(`Unsupported component declaration type ${ts.SyntaxKind[declaration.kind]}`);\n  }\n  if (!ts.isObjectBindingPattern(argument)) {\n    // if a component does not use props de-structuring, we do not detect default values\n    return {};\n  }\n  const values: Record<string, string> = {};\n  for (const element of argument.elements) {\n    if (ts.isIdentifier(element.name) && element.initializer) {\n      values[element.name.escapedText as string] = element.initializer.getText();\n    }\n  }\n  return values;\n}\n\nexport function extractProps(propsSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  const exportType = checker.getDeclaredTypeOfSymbol(propsSymbol);\n\n  return exportType\n    .getProperties()\n    .map((value): ExpandedProp => {\n      const declaration = extractDeclaration(value);\n      const type = checker.getTypeAtLocation(declaration);\n      return {\n        name: value.name,\n        type: stringifyType(type, checker),\n        rawType: type,\n        rawTypeNode: (declaration as ts.PropertyDeclaration).type,\n        isOptional: isOptional(type),\n        description: getDescription(value.getDocumentationComment(checker), declaration),\n      };\n    })\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function extractTypes(propsSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  const namespaceDeclaration = [\n    // if we got the namespace directly\n    ...(propsSymbol.getDeclarations() ?? []),\n    // find namespace declaration from the interface with the same name\n    ...(checker.getDeclaredTypeOfSymbol(propsSymbol).getSymbol()?.getDeclarations() ?? []),\n  ].find(decl => decl.kind === ts.SyntaxKind.ModuleDeclaration);\n  return unwrapNamespaceDeclaration(namespaceDeclaration).map(node => {\n    if (!ts.isTypeAliasDeclaration(node) && !ts.isInterfaceDeclaration(node)) {\n      throw new Error(`Unexpected node type ${ts.SyntaxKind[node.kind]}`);\n    }\n    return node;\n  });\n}\n\nexport function extractFunctions(componentName: string, typeNode: ts.Node | undefined, checker: ts.TypeChecker) {\n  if (!typeNode) {\n    return [];\n  }\n  const refType = checker.getTypeAtLocation(typeNode);\n  return refType\n    .getProperties()\n    .map((value): ExpandedProp => {\n      const declaration = extractDeclaration(value);\n      const type = checker.getTypeAtLocation(declaration);\n      const realType = type.getNonNullableType();\n      if (realType.getCallSignatures().length === 0) {\n        throw new Error(\n          `${componentName}Props.Ref should contain only methods, \"${value.name}\" has a \"${stringifyType(\n            type,\n            checker\n          )}\" type`\n        );\n      }\n      return {\n        name: value.name,\n        type: stringifyType(realType, checker),\n        rawType: realType,\n        rawTypeNode: (declaration as ts.PropertyDeclaration).type,\n        isOptional: isOptional(type),\n        description: getDescription(value.getDocumentationComment(checker), declaration),\n      };\n    })\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function extractExports(\n  componentName: string,\n  exportSymbols: ts.Symbol[],\n  checker: ts.TypeChecker,\n  extraExports: Record<string, Array<string>>\n) {\n  let componentSymbol;\n  let propsSymbol;\n  const unknownExports: Array<string> = [];\n  for (const exportSymbol of exportSymbols) {\n    if (exportSymbol.name === 'default') {\n      validateComponentType(componentName, exportSymbol, checker);\n      componentSymbol = exportSymbol;\n    } else if (exportSymbol.name === `${componentName}Props`) {\n      propsSymbol = exportSymbol;\n    } else if (!extraExports[componentName] || !extraExports[componentName].includes(exportSymbol.name)) {\n      unknownExports.push(exportSymbol.name);\n    }\n  }\n  if (unknownExports.length > 0) {\n    throw new Error(`Unexpected exports in ${componentName}: ${unknownExports.join(', ')}`);\n  }\n  if (!componentSymbol) {\n    throw new Error(`Missing default export for ${componentName}`);\n  }\n  if (!propsSymbol) {\n    throw new Error(`Missing ${componentName}Props export`);\n  }\n  return { componentSymbol, propsSymbol };\n}\n\nfunction validateComponentType(componentName: string, symbol: ts.Symbol, checker: ts.TypeChecker) {\n  const declaration = extractDeclaration(symbol);\n  let type: ts.Type;\n  if (ts.isExportAssignment(declaration)) {\n    // export default Something;\n    type = checker.getTypeAtLocation(declaration.expression);\n  } else if (ts.isFunctionDeclaration(declaration)) {\n    // export default function Something() {...}\n    type = checker.getTypeAtLocation(declaration);\n  } else {\n    throw new Error(`Unknown default export for ${componentName}`);\n  }\n  if (\n    // React.forwardRef\n    type.getSymbol()?.name !== 'ForwardRefExoticComponent' &&\n    // Plain function returning JSX\n    type.getCallSignatures().some(signature => {\n      const returnTypeName = checker.typeToString(signature.getReturnType());\n      return returnTypeName !== 'Element' && returnTypeName !== 'ReactPortal';\n    })\n  ) {\n    throw new Error(`Unknown default export type ${checker.typeToString(type)}`);\n  }\n}\n"]}