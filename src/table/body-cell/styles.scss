/*
 Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
*/

@use '../../internal/styles' as styles;
@use '../../internal/styles/tokens' as awsui;
@use '../../internal/hooks/focus-visible' as focus-visible;

$cell-vertical-padding: awsui.$space-scaled-xs;
// Calculate padding to prevent a shift in content after selection due to the difference
// between selected border widths and normal row divider widths (visual refresh).
$cell-vertical-padding-w-border: calc(
  #{$cell-vertical-padding} + (#{awsui.$border-item-width} - #{awsui.$border-divider-list-width})
);
$cell-horizontal-padding: awsui.$space-scaled-l;
$cell-edge-horizontal-padding: calc(#{awsui.$space-l} - #{awsui.$border-item-width});
$cell-horizontal-padding-w-border: calc(#{$cell-edge-horizontal-padding} + #{awsui.$border-item-width});
$selected-border: awsui.$border-item-width solid awsui.$color-border-item-selected;
$selected-border-placeholder: awsui.$border-divider-list-width solid awsui.$color-border-item-placeholder;
$border-placeholder: awsui.$border-item-width solid transparent;
$icon-width-with-spacing: calc(#{awsui.$size-icon-normal} + #{awsui.$space-xs});
// Right paddings of the absolute positioned icons (success icon is shown next to the edit icon)
$edit-button-padding-right: calc(
  #{awsui.$space-xs} + #{awsui.$space-xxs}
); // Cell vertical padding + xxs space that would normally come from the button.
$success-icon-padding-right: calc(#{$edit-button-padding-right} + #{$icon-width-with-spacing});

@mixin cell-focus-outline {
  @include styles.focus-highlight(calc(-1 * #{awsui.$space-scaled-xxs}));
  // @mixin focus-highlight sets cell's position to "relative".
  // Reinforcing sticky position for it to take precedence.
  &.sticky-cell {
    position: sticky;
  }
}

.expandable-toggle-wrapper {
  position: absolute;
  inset-block: 0;
  display: flex;
  align-items: center;
  margin-inline-start: calc(-1 * (#{awsui.$space-m} + #{awsui.$space-xs}));
}

@mixin cell-offset($padding) {
  padding-inline-start: $padding;

  @for $i from 1 through 9 {
    &.body-cell-expandable-level-#{$i} {
      padding-inline-start: calc($padding + $i * (#{awsui.$space-m} + #{awsui.$space-xs}));
    }
  }
  &.body-cell-expandable-level-next {
    padding-inline-start: calc($padding + 9 * (#{awsui.$space-m} + #{awsui.$space-xs}));
  }
}

.body-cell {
  box-sizing: border-box;
  padding-block-start: $cell-vertical-padding;
  padding-block-end: $cell-vertical-padding-w-border;
  @include cell-offset($cell-horizontal-padding);
  padding-inline-end: $cell-horizontal-padding;
  border-block-start: awsui.$border-divider-list-width solid transparent;
  word-wrap: break-word;
  border-block-end: awsui.$border-divider-list-width solid awsui.$color-border-divider-secondary;
  font-weight: inherit;

  @include focus-visible.when-visible {
    @include cell-focus-outline;
  }

  text-align: start;
  &:not(.body-cell-wrap) {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  &:first-child {
    border-inline-start: $border-placeholder;
  }
  &:last-child {
    border-inline-end: $border-placeholder;
    padding-inline-end: $cell-edge-horizontal-padding;
  }
  &.is-visual-refresh:first-child {
    &:not(.has-striped-rows) {
      @include cell-offset(awsui.$space-xxxs);
      &:not(.body-cell-edit-active).body-cell-interactive.body-cell-editable:hover {
        @include cell-offset(calc(#{awsui.$space-xxxs} + #{awsui.$border-divider-list-width}));
      }
    }

    /*
      Striped rows requires additional left padding because the
      shaded background makes the child content appear too close
      to the table edge.
      */
    &:first-child.has-striped-rows {
      @include cell-offset(awsui.$space-xxs);
      &-sticky-cell-pad-left {
        @include cell-offset(awsui.$space-table-horizontal);
      }
    }

    /*
      Remove the placeholder border if the row is not selectable.
      Rows that are not selectable will reserve the horizontal space
      that the placeholder border would consume.
      */
    &:not(.has-selection):not(.body-cell-editable) {
      border-inline-start: none;
    }
  }
  &:first-child:not(.is-visual-refresh) {
    @include cell-offset($cell-edge-horizontal-padding);
  }
  &-first-row {
    border-block-start: $border-placeholder;
  }
  &-last-row:not(.body-cell-selected) {
    &:not(.has-footer) {
      // skip the border for the last row because the container already has a border
      border-block-end: $border-placeholder;
    }

    &.has-footer {
      /*
      Add a bottom border to the body cells of the last row as a separator between the
      table and the footer
      */
      border-block-end: awsui.$border-divider-section-width solid awsui.$color-border-divider-default;
    }
  }
  &-shaded {
    background: awsui.$color-background-cell-shaded;
  }
  &-selected {
    background-color: awsui.$color-background-item-selected;
    border-block-start: $selected-border;
    border-block-end: $selected-border;
    padding-block-end: $cell-vertical-padding;

    // Last selected row has a fixed border-bottom width which do not change on selection in visual refresh.
    // Adjust padding-bottom prevents a slight jump in the table height.
    &.body-cell-last-row.is-visual-refresh {
      padding-block-end: calc(#{$cell-vertical-padding} + #{awsui.$border-divider-list-width});
    }

    &:first-child {
      border-inline-start: $selected-border;
      border-start-start-radius: awsui.$border-radius-item;
      border-start-end-radius: 0;
      border-end-start-radius: awsui.$border-radius-item;
      border-end-end-radius: 0;
    }
    &:last-child {
      border-inline-end: $selected-border;
      border-start-start-radius: 0;
      border-start-end-radius: awsui.$border-radius-item;
      border-end-start-radius: 0;
      border-end-end-radius: awsui.$border-radius-item;
    }
  }

  &.sticky-cell {
    position: sticky;
    background: awsui.$color-background-container-content;
    z-index: 798; // Our sticky elements should have z-index in the range of 800-850, this value needs to be lower
    &-pad-left:not(.has-selection):not(.is-visual-refresh.body-cell:first-child.has-striped-rows) {
      @include cell-offset(awsui.$space-table-horizontal);
    }
    &.body-cell-shaded {
      background: awsui.$color-background-cell-shaded;
    }
    &.body-cell-selected {
      background-color: awsui.$color-background-item-selected;

      // Create a background using box-shadow and clip path to hide underlying elements
      &:first-child {
        box-shadow: 0 0 0 4px awsui.$color-background-container-content;
        clip-path: inset(0 0 0 0);
      }
      &:last-child {
        box-shadow: 4px 0 0 0 awsui.$color-background-container-content;
        clip-path: inset(0 0 0 0);
        &.sticky-cell-last-right {
          box-shadow: awsui.$shadow-sticky-column-last, 8px 0 0 0 awsui.$color-background-container-content;
          clip-path: inset(0 0 0 -24px);
        }
      }
    }
    &-last-left {
      box-shadow: awsui.$shadow-sticky-column-first;
      clip-path: inset(0px -24px 0px 0px);
    }
    &-last-right {
      box-shadow: awsui.$shadow-sticky-column-last;
      clip-path: inset(0 0 0 -24px);
    }
    @include styles.with-motion {
      transition-property: padding;
      transition-duration: awsui.$motion-duration-transition-show-quick;
      transition-timing-function: awsui.$motion-easing-sticky;
    }
  }

  // Use padding as a selected border placeholder to make sure rows don't change height on selection (visual refresh)
  &-selected:not(:first-child) {
    padding-block-start: $cell-vertical-padding-w-border;
  }
  &:not(.body-cell-selected).body-cell-next-selected {
    border-block-end: 0;
    padding-block-end: calc(#{$cell-vertical-padding} + #{awsui.$border-divider-list-width});
  }
  &-selected.body-cell-prev-selected {
    padding-block-start: $cell-vertical-padding-w-border;
    border-block-start: $selected-border-placeholder;
  }
  &-selected.body-cell-next-selected {
    border-block-end-width: awsui.$border-divider-list-width;
  }
  // Remove border radii for consecutive selected rows (visual refresh)
  &-selected.body-cell-next-selected:first-child {
    border-end-start-radius: 0;
  }
  &-selected.body-cell-next-selected:last-child {
    border-end-end-radius: 0;
  }
  &-selected.body-cell-prev-selected:first-child {
    border-start-start-radius: 0;
  }
  &-selected.body-cell-prev-selected:last-child {
    border-start-end-radius: 0;
  }
  // Reset padding for selected rows with no adjacent selected row above it,
  // because rows reuse adjacent selected borders (visual refresh)
  &-selected:not(.body-cell-prev-selected) {
    padding-block-start: $cell-vertical-padding;
  }

  &-editor-wrapper {
    padding-block: 0;
    padding-inline-start: 0;
    padding-inline-end: $edit-button-padding-right;
  }

  &-success {
    padding-block: 0;
    padding-inline-start: 0;
    padding-inline-end: $success-icon-padding-right;
  }

  &-success,
  &-editor-wrapper {
    inset-block: 0;
    inset-inline-end: 0;
    position: absolute;

    display: flex;
    align-items: center;
    justify-content: flex-end;
  }
  &-editor {
    // Reset some native <button> styles
    cursor: pointer;
    outline: 0;
    background: 0;
    border-block: 0;
    border-inline: 0;
    padding-block: 0;
    padding-inline: 0;

    // This gives the editor button a small area even when the icon is not rendered.
    // That is to allow programmatic interaction in tests.
    min-block-size: 10px;
    min-inline-size: 10px;

    color: awsui.$color-text-button-normal-default;
    &-disabled {
      color: awsui.$color-text-disabled-inline-edit;
    }
    &:hover {
      color: awsui.$color-text-button-normal-hover;
    }
    &:active {
      color: awsui.$color-text-button-normal-active;
    }

    &-form {
      margin-block: calc(-1 * #{awsui.$space-xs});
      margin-inline: calc(-1.5 * #{awsui.$space-xs});

      .is-visual-refresh.body-cell:first-child.has-striped-rows > & {
        margin-inline-start: calc(-1 * #{awsui.$space-xxs});
      }

      .is-visual-refresh.body-cell:first-child:not(.has-striped-rows) > & {
        margin-inline-start: calc(-1 * #{awsui.$space-xxxs});
      }
    }

    &-row {
      display: flex;
      flex-flow: row nowrap;
      align-items: center;
      justify-content: space-between;
      column-gap: awsui.$space-xxs;
      & > :not(:last-child) {
        flex-grow: 1;
      }
    }
    &-controls {
      flex-shrink: 0;
    }
  }

  &.body-cell-expandable {
    position: relative;

    &.sticky-cell {
      position: sticky;
    }
  }

  &.body-cell-editable {
    position: relative;

    &.sticky-cell {
      position: sticky;
    }

    &.body-cell-edit-active {
      overflow: visible;
      &.sticky-cell {
        position: sticky;
      }
    }

    &:not(.body-cell-edit-active) {
      &.body-cell-interactive {
        cursor: pointer;
      }

      @mixin focused-editor-styles {
        padding-inline-end: calc(#{$cell-horizontal-padding} + #{awsui.$space-l});
        & > .body-cell-editor-wrapper,
        & > .expandable-cell-content > .body-cell-editor-wrapper {
          opacity: 1;
        }
        & > .body-cell-success {
          opacity: 1;
        }
      }
      & > .body-cell-editor-wrapper,
      & > .expandable-cell-content > .body-cell-editor-wrapper {
        opacity: 0;
      }

      // Showing focus outline for the cell.
      // We don't use our focus-visible polyfill here because it doesn't work properly with screen readers.
      // These edit buttons are special because they are visually hidden (opacity: 0), but exposed to assistive technology.
      // It's therefore important to display the focus outline, even when a keyboard use wasn't detected.
      // For example, when an edit button is selected from the VoiceOver rotor menu.
      &.body-cell-interactive:focus-within {
        @include cell-focus-outline;
      }
      // When a cell is not interactive the focus outline must be present for the editor button.
      &:not(.body-cell-interactive) > .body-cell-editor-wrapper > .body-cell-editor,
      &:not(.body-cell-interactive) > .expandable-cell-content > .body-cell-editor-wrapper > .body-cell-editor {
        @include focus-visible.when-visible {
          @include styles.focus-highlight(awsui.$space-button-inline-icon-focus-outline-gutter);
        }
      }

      &:not(.body-cell-interactive),
      &:focus-within:focus-within,
      &.body-cell-edit-disabled-popover {
        padding-inline-end: calc(#{$cell-horizontal-padding} + #{awsui.$space-l});
        &.body-cell-has-success {
          // After a successful edit, we display the success icon next to the edit button and need additional padding to not let the text overflow the success icon.
          padding-inline-end: calc(#{$cell-horizontal-padding} + #{awsui.$space-l} + #{$icon-width-with-spacing});
        }
        @include focused-editor-styles;
        &.sticky-cell {
          position: sticky;
        }
      }

      &.body-cell-interactive:hover {
        background-color: awsui.$color-background-dropdown-item-hover;
        border-block: awsui.$border-divider-list-width solid awsui.$color-border-editable-cell-hover;
        border-inline: awsui.$border-divider-list-width solid awsui.$color-border-editable-cell-hover;
        inset-inline: calc(-1 * #{awsui.$border-divider-list-width});
        position: relative;

        &:first-child {
          inset-inline: 0;
        }

        & > .body-cell-editor-wrapper,
        & > .expandable-cell-content > .body-cell-editor-wrapper {
          padding-inline-end: calc(#{$edit-button-padding-right} - (2 * #{awsui.$border-divider-list-width}));
        }
        & > .body-cell-success {
          // Update padding to avoid a jumping icon because of the additional borders added when hovering an editable cell.
          padding-inline-end: calc(#{$success-icon-padding-right} - (2 * #{awsui.$border-divider-list-width}));
        }
        &.body-cell-last-row.body-cell-selected,
        &.body-cell-next-selected {
          padding-block: calc(#{$cell-vertical-padding} - calc(#{awsui.$border-divider-list-width} / 2));
        }
        &.body-cell-last-row:not(.body-cell-selected) {
          padding-block-start: calc(#{$cell-vertical-padding} - calc(#{awsui.$border-divider-list-width}));
        }
        &.body-cell-first-row:not(.body-cell-selected) {
          padding-block: calc(#{$cell-vertical-padding} - calc(#{awsui.$border-divider-list-width}));
        }
        &.sticky-cell {
          position: sticky;
        }
        @include focused-editor-styles;
      }
    }
  }
  &-editable.is-visual-refresh:not(.body-cell-edit-active).body-cell-interactive:hover {
    &:first-child {
      border-start-start-radius: awsui.$border-radius-item;
      border-end-start-radius: awsui.$border-radius-item;
    }
    &:last-child {
      border-start-end-radius: awsui.$border-radius-item;
      border-end-end-radius: awsui.$border-radius-item;
    }
    &.body-cell-first-row > .body-cell-success,
    &.body-cell-first-row > .body-cell-editor-wrapper,
    &.body-cell-first-row > .expandable-cell-content > .body-cell-editor-wrapper {
      padding-block-start: awsui.$border-divider-list-width;
    }
  }
}
